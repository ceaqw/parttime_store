/********************************************************************
* 文件名  ： 通用文件.c
* 描述    :  该程序包含两个 ms/us 延时程序和任意数字转字符串程序
*********************************************************************/
#include "common.h"


/********************************************************************
* 名称 : delay_ms()
* 功能 : 延时,延时时间大概为nms
* 输入 : 无
* 输出 : 无
***********************************************************************/
void  delay_ms(uchar nms)
{
#if MAIN_Fosc == 12000000L
    unsigned char i, j;			//软件延时函数
    do
    {
        i = 2;
        j = 239;
        do
        {
            while (--j);
        }
        while (--i);
    }
    while(--nms);
#elif MAIN_Fosc == 11059200L
    unsigned char i, j;				//软件延时函数
    do
    {
        _nop_();
        i = 2;
        j = 199;
        do
        {
            while (--j);
        }
        while (--i);
    }
    while(--nms);

#endif
}

#include <reg52.h>
#include <intrins.h>
#include "lcd1602.h"		//这个是自定义头文件导入
#include "common.h"			//这个是自定义头文件导入

sbit RS = P2^5;				//lcd1602三个时序控制针脚定义
sbit RW = P2^6;
sbit E = P2^7;

#define DataPort P0				//lcd1602数据传输端口定义

void lcd_clear(void)			
{
     lcd_write_com(0x01);		//写入lcd命令清屏
     delay_ms(5);			//延时5ms
}

void lcd_write_com(unsigned char byte)		//写入lcd一个命令
{
      RS = 0;		//三个时序控制引脚，打开数据传输，模式为命令输入
      RW = 0;
      E = 1;
      DataPort = byte;		//数据传输针脚传输数据
      _nop_();
      _nop_();
      delay_ms(1);
      E = 0;
        
}

void lcd_write_data(unsigned char byte)	//写入lcd一个字符的数据
{
      RS = 1;		//三个时序控制引脚，打开数据传输，模式为数据输入
      RW = 0;
      E = 1;
      DataPort = byte;		//数据传输针脚传输数据
      _nop_();
      _nop_();
      delay_ms(1);
      E = 0;
}

void lcd_init()
{
      delay_ms(5);
      lcd_write_com(0x38);//设置16*2显示，5*7点阵，8位数据接口
      delay_ms(5);
      lcd_write_com(0x38);//设置16*2显示，5*7点阵，8位数据接口
      delay_ms(5);
      lcd_write_com(0x38);//设置16*2显示，5*7点阵，8位数据接口
      delay_ms(5);
      lcd_write_com(0x08); //关闭显示
      delay_ms(5);
      lcd_write_com(0x01);//清屏指令
      delay_ms(5);
      lcd_write_com(0x06);
      delay_ms(5);
      lcd_write_com(0x0c);
      delay_ms(5);
      
}
void lcd_write_char(unsigned char x,unsigned char y,unsigned char byte)		//设置lcd显示的字符及位置
{
      if(0 == y)
        {
            lcd_write_com(0x80 + x);		//设置显示列
        }
      else if(1 == y)
        {
            lcd_write_com(0x80 + 0x40 + x);		//设置显示列
        }
        lcd_write_data(byte);			//写入字符信息
}

void lcd_write_str(unsigned char x, unsigned char y, unsigned char *s)		//设置lcd显示的字符及位置
{
     if(0 == y)
        {
            lcd_write_com(0x80 + x);//设置显示列
        }
      else
        {
            lcd_write_com(0x80 + 0x40 + x);//设置显示列
        }
        
        while(*s)		//循环写入字符串信息
        {
            lcd_write_data(*s);		
            s++;
        }
        
}


#include "common.h"
#include "lcd1602.h"



/*
	说明：lcd1602为16列2行显示器，
	其操作命令如下：
		一、1602里的存储器有三种：CGROM、CGRAM、DDRAM。CGROM 保存了厂家生产时固化在LCM中的点阵型显示数据，CGRAM是留给用户自己定义点阵型显示数据的，DDRAM则是和显示屏的内容对应的。1602内部的 DDRAM有80字节，而显示屏上只有2行 ×16列，共32个字符，所以两者不完全一一对应。默认情况下，显示屏上第一行的内容对应DDRAM中80H到8FH的内容，第二行的内容对应DDRAM 中C0H到CFH的内容。DDRAM中90H到A7H、D0H到E7H的内容是不显示在显示屏上的，但是在滚动屏幕的情况下，这些内容就可能被滚动显示出来了。注：这里列举的DDRAM的地址准确来说应该是DDRAM地址+80H之后的值，因为在向数据总线写数据的时候，命令字的最高位总是为1。

		二、1602使用三条控制线：EN、RW、RS。其中EN起到类似片选和时钟线的作用，RW和RS指示了读、写的方向和内容。在读数据（或者Busy标志）期间，EN线必须保持高电平；而在写指令（或者数据）过程中，EN线上必须送出一个正脉冲。RW、RS的组合一共有四种情况，分别对应四种操作：

		RS＝0、RW＝0——表示向LCM写入指令
		RS＝0、RW＝1——表示读取Busy标志
		RS＝1、RW＝0——表示向LCM写入数据
		RS＝1、RW＝1——表示从LCM读取数据

		三、LCD在使用的过程中，可以在RS＝0、RW＝0的情况下,向LCM写入一个字节的控制指令。使用的控制指令一共八个类别。有的类别又有几条不同的指令。具体的情况罗列在下：

		①01H：清除DDRAM的所有单元，光标被移动到屏幕左上角。
		②02H：DDRAM所有单元的内容不变，光标移至左上角。
		③输入方式设置（EnterModeSet），这些指令规定了两个方面：一是写入一个DDRAM单元后，地址指针如何改变（加一还是减一）；二是屏幕上的内容是否滚动。
		04H：写入DDRAM后，地址指针减一，比如第一个字符写入8FH，则下一个字符会写入8EH；屏幕上的内容不滚动。
		05H：写入DDRAM后，地址指针减一，同上一种情况；每一个字符写入以后，屏幕上的内容向右滚动一个字符位。
		06H：写入DDRAM后，地址指针加一，比如第一个字符写入80H，则下一个字符会写入81H；屏幕上的内容也是不滚动。这应该是最常用的一种显示方式。
		07H：写入DDRAM后，地址指针加一，同上一种情况；每一个字符写入以后，屏幕上的内容向左滚动一个字符位。
		④屏幕开关、光标开关、闪烁开关。
		08H、09H、0AH、0BH：关闭显示屏，实质上是不把DDRAM中的内容对应显示在屏幕上，对DDRAM的操作还是在进行的，执行这条指令，接着对 DDRAM进行写入，屏幕上没有任何内容，但是接着执行下面的某条指令，就能看到刚才屏幕关闭期间，对DDRAM操作的效果了。
		0cH：打开显示屏，不显示光标，光标所在位置的字符不闪烁。
		0dH：打开显示屏，不显示光标，光标所在位置的字符闪烁。
		0eH：打开显示屏，显示光标，光标所在位置的字符不闪烁。
		0fH：打开显示屏，显示光标，光标所在位置的字符闪烁。
		关于光标的位置：光标所在的位置指示了下一个被写入的字符所处的位置，加入在写入下一个字符前没有通过指令设置DDRAM的地址，那么这个字符就应该显示在光标指定的地方。
		⑤设置光标移动（本质就是AC的增加还是减少）、整体画面是否滚动。
		10H：每输入一次该指令，AC就减一，对应了光标向左移动一格。整体的画面不滚动。
		14H：每输入一次该指令，AC就加一，对应了光标向右移动一格。整体的画面不滚动。
		18H：每输入一次该指令，整体的画面就向左滚动一个字符位。
		1CH：每输入一次该指令，整体的画面就向右滚动一个字符位。画面在滚动的时候，每行的首尾是连在一起的，也就是每行的第一个字符，若左移25次，就会显示在该行的最后一格。在画面滚动的过程中，AC的值也是变化的。
		⑥显示模式设定指令，设定了显示几行，显示什么样的点阵字符，数据总线占用几位。
		20H：4位总线，单行显示，显示5×7的点阵字符。
		24H：4位总线，单行显示，显示5×10的点阵字符。
		28H：4位总线，双行显示，显示5×7的点阵字符。
		2CH：4位总线，双行显示，显示5×10的点阵字符。
		30H：8位总线，单行显示，显示5×7的点阵字符。
		34H：8位总线，单行显示，显示5×10的点阵字符。
		38H：8位总线，双行显示，显示5×7的点阵字符。这是最常用的一种模式。3CH：8位总线，双行显示，显示5×10的点阵字符。
*/




sbit MQ = P1^1;			//这些应该是你的设备的引脚定义了在此我就不做解释了
sbit LED = P1^0;
sbit BEEP = P2^0;

void main()
{
      lcd_init();			//lcd1602初始化做准备，即清屏等
      lcd_write_str(0,0,"     Normal     ");		//在0行0列显示该字符串
      lcd_write_str(0,1,"                ");		//在1行0列显示该字符串
    
        while(1)
        {
             if(MQ == 0)			//当这个引脚为低电平
             {
                   lcd_write_str(0,0," Bad wicked ill ");		//在0行0列显示该字符串
                   LED = ~LED;			//LED引脚取反电平
                   BEEP = 0;			//蜂鸣器打开
                   delay_ms(100);   //延时100ms
             }
             else		
             {
                     lcd_write_str(0,0,"     Normal     ");		//在0行0列显示该字符串
                   LED = 1;			//LED关闭
                   BEEP = 1;		//蜂鸣器关闭
             }
             delay_ms(10);    
        }
}